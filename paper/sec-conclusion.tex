%\enlargethispage{1em}
\vspace{-5mm}
\section{Conclusions and Discussion}
\label{sec:conclusions}

In this paper, we introduce \name, a converged relational-graph optimization framework designed for SQL/PGQ queries. We formulate the \spjm query skeleton to better analyze and optimize the relational-graph hybrid queries introduced by SQL/PGQ. After discovering that a graph-agnostic approach can result in a larger search space and suboptimal query plans, we design \name to optimize the relational and graph components of \spjm queries using dedicated relational and graph optimization modules, respectively. Additionally, \name incorporates optimization rules, such as \filterrule, which optimize queries across the relational and graph components, further enhancing overall query efficiency.
We conduct extensive experiments comparing \name to graph-agnostic baselines, demonstrating its superior performance and confirming the effectiveness of our optimization techniques.
% We conduct extensive experiments to evaluate the performance of \name against graph-agnostic baselines, demonstrating its superior performance and confirming the effectiveness of the proposed optimization techniques.


%However, \revise{there is an inevitable gap between relational data and graph data. One important distinction is that not every relation can be clearly identified as either a vertex relation or an edge relation. For example, in the JOB dataset, some tables contain more than two foreign keys, and some of these foreign keys reference the primary key of a vertex relation, making it difficult to definitively classify them as either vertex or edge relations. Another important difference is that joins between relational tables can occur in any order, whereas in plans generated by graph optimizers, vertex relations and edge relations need to alternate. Therefore, the relational optimizer has a larger search space, which can sometimes lead to better results.}

One \revise{interesting future direction is to extend \name to directly process existing \spj queries as inputs, enabling the automatic conversion from \spj to \spjm queries while being aware of the presence of graph indices. Boudaoud et al.~\cite{Boudaoud2022} may have discussed potential methods for such conversion. However, designing a global solution to determine which parts of an \spj query can be converted into a matching operator is challenging. This decision involves exhaustively exploring the search space, now including both join and pattern matching options. Given the high cost of optimizing joins alone, an exhaustive search could become prohibitively expensive. Therefore, it is necessary to carefully balance and select appropriate global and local optimization rules for given queries.}


% Future work includes integrating \name with more widely-used backend databases to expand its applicability and impact.



\balance
