\section{Introduction}

SQL/Property Graph Queries (abbr.~SQL/PGQ) is Part 16 of SQL 2023, which has endowed traditional SQL with the ability to define and query graphs on top of relational databases.
In SQL/PGQ, Graphs are presented as views, and the vertices and edges in the graphs are represented as tables.
Please note that with SQL/PGQ, graph queries and relational queries can be expressed in one statement and optimized together for a better execution plan.
An example of a SQL/PGQ query is provided in Example \ref{example:introduction:sqlpgq}.

\begin{example}
    \label{example:introduction:sqlpgq}
    In this example, three tables, i.e., \textbf{Person, Knows, Department}, are stored in the relational database.
    With SQL/PGQ, a graph view named \textbf{friendship\_graph} is created based on tables \textbf{Person} and \textbf{Knows}.
    Specifically, rows in table \textbf{Person} represent the vertices in the graph while rows in table \textbf{Knows} represent the edges.
    Besides, the department a person belonging to is stored in table \textbf{Person} as a foreign key (\textit{dept\_id}).

    Suppose we are going to find three persons satisfying: (1) They know each other; (2) Two of them belong to the Department of Computer Science.
    Then, the corresponding SQL/PGQ query is as follows:
    \begin{lstlisting}
        SELECT person1, person2, person3
        FROM Department p, GRAPH_TABLE (friendship_graph
            MATCH (p1:Person)-[:Knows]-(p2:Person)-[:Knows]-(p3:Person),
            (p1)-[:Knows]-(p3)
            COLUMNS (
                p1.name as pn1,
                p1.dept_id as dept1,
                p2.name as pn2,
                p2.dept_id as dept2,
                p3.name as pn3,
                p3.dept_id as dept3
            )
        )
        WHERE dept1 = p.dept_id
        AND dept2 = p.dept_id AND
        AND p.dept_name = 'Computer Science';
    \end{lstlisting}
    According to the first condition, the wanted three persons should form a triangle in \textbf{friendship\_graph}.
    It is a problem of pattern matching, and such triangles are searched for on the graph view.
    The output of the graph query is a table (named f) with three columns, i.e., person1, person2, and person3, representing the identifiers of the three persons, respectively.

    For the second condition, due to the existence of the foreign key, it is efficient to perform natural join between table f and table \textbf{Department} to obtain the ideal results.
    Please note that the results of graph queries in SQL/PGQ are still tables, and such returned tables can be exploited in relational queries.
\end{example}

Query optimization is crucial for query processing.
The optimizer can significantly influence the efficiency of query processing.
There are already many works about relational query optimizers and graph query optimizers.
However, neither of them are suitable for SQL/PGQ queries.
Because they can only optimize the queries from the relational perspective or the graph perspective, but not both.
In this paper, we are going to propose a new converged framework for query optimization of SQL/PGQ statements.

There are mainly three challenges.

\textbf{Challenge 1. Relational optimizers cannot be used to optimize graph queries directly (or with limited efficiency)}.
It is true that the vertices and edges in graphs can be represented as corresponding tables in relational databases, and the paths in the graphs can be translated into join operators in relational algebra.
However, since the relational optimizers only take the relational operators into consideration, some efficient graph operators (e.g., get edge, get vertex, get neighbors with graph indices) are ignored in the process of optimization.
Therefore, the search space is artificially reduced, the best physical plan are likely to be missed.
An intuitive idea is to replace some relational operators with graph operators after the physical plans are obtained (e.g., replace some join operators with getV/getE/getNeighbor in graph operators) to take advantage of the benefits brought about by graph operators.
Then, the obtained new plan are probabily not the optimizal plan, and the estimated costs are inaccurate.
Moreover, some efficient replacement may be impossible w.r.t.~the obtained physical plan due to the order of joining tables representing vertices and edges.

\begin{figure*}
    \centering
    \begin{subfigure}[b]{0.4\linewidth}
        \centering
        \includegraphics[width=\linewidth]{./figures/intro-order-case.png}
        \caption{Relationship 1.}
        \label{fig:intro-order-case}
    \end{subfigure}
    \begin{subfigure}[b]{0.4\linewidth}
        \centering
        \includegraphics[width=\linewidth]{./figures/intro-order-case-2.png}
        \caption{Relationship 2.}
        \label{fig:intro-order-case2}
    \end{subfigure}
    \caption{Graphs representing the relationships among tuples in different tables. In detail, tuples in Tables \textbf{Contributor} and \textbf{Repository} represent vertices in the graph, while those in Tables \textbf{Follows} and \textbf{Contirbute} represent edges.}
    \label{fig:intro-replace-example}
\end{figure*}


\begin{example}
    Given four tables \textbf{Contributor}, \textbf{Follows}, \textbf{Contribute}, and \textbf{Repository} as shown in Fig.~\ref{fig:intro-order-case}, the relationships among their tuples are presented.
    Specifically, edge (v1, e1) means that e1.contr\_id = v1.contr\_id and edge (e1, r1) means that e1.repo\_id = r1.repo\_id.

    Given a query as follows:
    \begin{lstlisting}
        SELECT p2.contr_id, repo_name
        FROM Contributor p1, Follows f, Contributor p2, Contribute c, Repository p
        WHERE p1.contr_id = 1 
        AND p1.contr_id = f.contr2_id 
        AND p2.contr_id = f.contr1_id
        AND p1.contr_id = c.contr_id 
        AND c.repo_id = r.repo_id;
    \end{lstlisting}
    from the perspecitve of a relational database (e.g., DuckDB), the best join order can be \textbf{p1$\rightarrow$f$\rightarrow$p2$\rightarrow$c$\rightarrow$r}, since Tables \textbf{Follows} and \textbf{Contributor} has much smaller cardinalities than Table \textbf{Contribute}.
    Then, by replacing the join operators with getNeighbor, the finally obtained execution plan is \textbf{p1$\xrightarrow{\textit{getNeighbor}}$p2$\xrightarrow{\textit{getNeighbor}}$r}.

    However, as $v_1$ has much fewer neighbors in Table \textbf{Repository} than in Table \textbf{Contributor}, join order \textbf{p1$\xrightarrow{\textit{getNeighbor}}$r$\xrightarrow{\textit{getNeighbor}}$p2} would be more efficient from the perspective of graph databases.
    Therefore, it suggests that replacing relational operators with graph operators after optimization with relational optimizers can miss the optimial execution plans.

    Besides, given the relationships among the tuples as shown in Fig.~2a, the best join order from the perspective of a relational database like DuckDB can be \textbf{p1$\rightarrow$f$\rightarrow$c$\rightarrow$p2$\rightarrow$r},

    %An example about replace join with getV/getE/getNeighbor,
    %or the example of duckdb, whether to indicate more constraints (due to the unawareness of getNeighbor)
\end{example}


\textbf{Challenge 2. Graph optimizers sometimes cannot be used to optimize relational queries directly}.
Relational queries cannot always be expressed as graph queries with no effort.
When the tables in a relational query do not possess the semantics of vertices and edges, graph optimizers cannot be applied to optimize such queries.
An example is as follows:

\begin{example}
    An example about:
    relation query for [p1]-join-[p2]-join-[p3]
    where, person p1, p2, and p3 have the same birthday
    Then, none of the tables can represent the edges, and the graph optimizer cannot be applied.
    An alternative is to create a new table \textbf{HAS\_SAME\_BIRTHDAY} = (id, person1id, person2id), each of whose record represents two persons having the same birthday.
    Then, the query should be converted to [p1]-join-[hsb]-join-[p2]-join=[hsb]-join-[p3].
    However, it is not practical to create new tables in the process of query optimization.
\end{example}

Moreover, relational query optimization has undergone numerous years of research and has accumulated a significant body of research findings.
Therefore, it would be unwise to abandon relational query optimization in favor of direct graph query optimization.


\textbf{Challenge 3. How to ensure worst-case-optimal joins (WCOJs)}.
Graph queries can be much more complex than relational queries, and multiple joins are common in graph queries.
Then, it is necessary to support WCOJs in the optimizer, which can reduce the complexity of 


In this paper, we propose a new converged optimization framework for SQL/PGQ.
It can optimize SQL/PGQ statements for query.
Specifically, the framework first optimize the graph queries in the statement and generate the corresponding graph physical plans.
[Since there may be join operators in the graph physical plans, the plan can be considered to be connected with join operators.
Then, the plan is combined with the left relational queries, the new query is optimized again with the relational optimizer.]

The contributions of this paper is mainly as follows:

(1) To the best of our knowledge, this is the first optimization framework for SQL/PGQ.
Property graphs are represented as views in SQL/PGQ, and vertices and edges are associated with tables in the relational databases.
Then, it is crucial to offer the converged query optimizer efficient for both relational and graph queries.

(2) The framework is the first to [unify] the inputs and outputs of the graph optimizer and relational optimizer based on the graph relational algebra, and propose the nested optimization strategy (abbr.~NOS) for SQL/PGQ queries.
In detail, given a SQL/PGQ query, NOS first optimizes the graph queries with the graph optimizer.
The output plan is then optimized together with the relational queries by the relational optimizer.
% In the framework, we design and implement numerous important operators for graph optimizer, including getV, getE, getNeighbor, and extendIntersect.
% Specifically, the extendIntersect operator is helpful in supporting worst-case optimality.

(3) Theoretical analysis on the complexity of the optimization framework is conducted.
The obtained theorems prove that for graph queries, the join order optimization with a graph optimizer can be exponentially faster than that with a relational optimizer. 
It theoretically confirms that relational optimizer is usually not suitable for graph queries, and it is indispensable for the existence of a converged optimization framework.

(4) Extensive experiments are conducted to show the efficiency of the proposed converged query optimization framework.
The experimental results show that the framework can be ?$\times$ faster than the baselines.

The rest of this paper is organized as follows.


